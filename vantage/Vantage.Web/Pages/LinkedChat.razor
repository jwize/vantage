@page "/linked-chat"
@inject ChatClient _client
@inject StateService _stateService
@inject ReplacementLinkService _replacementLinkService
@inject IJSRuntime JS

@implements IDisposable

@using Vantage.Web.Models
@using StrawberryShake
@using StrawberryShake.Extensions
@using Vantage.Web.Services


<div class="container">
    <div hidden="@(_ready)">
        Loading chat messaging...
    </div>

    <div class="box box-upper">
        @foreach (var comment in _comments)
        {
            @if (comment.User.Direction == Direction.Left)
            {
                <div class="@(GetTextDirection(comment.User.Direction)) chat-bubble">
                    <small>@comment.User.Name:</small> @(new MarkupString(GetReplacement(comment.Content)))
                </div>
            }
            else
            {
                <div class="@(GetTextDirection(comment.User.Direction)) chat-bubble">
                    @(new MarkupString(GetReplacement(comment.Content))) <small>: @comment.User.Name</small>
                </div>
            }
            
        }
    </div>

    <div class="box box-lower form-floating;">
        <div>
            <textarea @bind="_comment" @bind:event="oninput" class="form-control" placeholder="Enter message here"
                      @onkeydown="@Enter"></textarea>
        </div>

        <div class="text-right">

            <button type="button" class="btn btn-primary add-comment"
                    @onclick="() => OnAddCommentAsync(_comment)"
                    disabled="@(!_isValid)">
                Send
            </button>
        </div>
    </div>
</div>

@code
{
    private User _user { get; set; }
    private List<Comment> _comments = new();
    private string _comment { get; set; }
    private bool _isValid => !string.IsNullOrEmpty(_comment);
    private bool _ready { get; set; }
    private Dictionary<int, string> _hashedComments = new();

    private string GetTextDirection(Direction direction)
    {
        return direction == Direction.Left ? "text-left" : "text-right";
    }

    protected override async Task OnInitializedAsync()
    {
        // watch for comments added
        await _replacementLinkService.InitializeReplacementLinks();

        BeginCommentWatcher();
        BeginReplacementLinkWatcher();

        await SetInitialUser();

        RefreshComments();

        await _stateService.ShareStateAsync(StateService.LinkedChat);
        _stateService.Notify += OnShareState;

        _ready = true;

        StateHasChanged();
    }


    private async void RefreshComments()
    {
        _comments.Clear();

        var result = await _client.GetComments.ExecuteAsync();
        result.EnsureNoErrors();

        if (result.Data == null) return;
        var data = Array.Empty<IGetComments_Comment>();

        _comments = (result.Data.Comment ?? data).Select(t =>
        {
            var comment = new Comment
            {
                Content = t?.Content,
                User = new User
                {
                    Name = t?.User?.Name,
                    Direction = t?.User?.Name == "Jaime" ? Direction.Left : Direction.Right
                }
            };
            HashReplacement(comment.Content);
            return comment;

        }).ToList();
        StateHasChanged();
    }


    private void BeginCommentWatcher()
    {
        Task.Run(() =>
        {
            _client.OnAddedComment.Watch()
                .Subscribe(x =>
                {
                    var comment = x.Data?.Created;

                    var added = new Comment
                    {
                        Id = comment?.Id ?? 0,
                        User = new User()
                        {
                            Id = comment?.UserId ?? 0,
                            Name = comment?.User?.Name,
                            Direction = comment?.User?.Name == "Jaime" ? Direction.Left : Direction.Right
                        },
                        Content = comment?.Content
                    };

                    HashReplacement(comment?.Content);

                    _comments.Add(added);
                    StateHasChanged();
                });
        });
    }

    private string GetReplacement(string content)
    {
        var hash = content.GetHashCode();
        return _hashedComments[hash];
    }

    private void HashReplacement(string content)
    {
        var hash = content.GetHashCode();
        if (!_hashedComments.ContainsKey(hash))
        {
            _hashedComments.Add(hash, string.Empty);
        }

        var replacements = _replacementLinkService.ReplacementLinks;
        var output = content;
        foreach (var replacement in replacements)
        {
            output = output.Replace(replacement.Keyword, $"<a target='_blank' href='{replacement.Hyperlink}'>{replacement.Keyword}</a>");
        }
        _hashedComments[hash] = output;
    }

    private void BeginReplacementLinkWatcher()
    {
        Task.Run(() =>
        {
            _client.OnReplacementLinkCreated.Watch()
                .Subscribe(x =>
                {
                    var link = x?.Data?.Created;
                    _replacementLinkService.ReplacementLinks.Add(new ReplacementLink()
                    {
                        Keyword = link?.Keyword,
                        Hyperlink = link?.Hyperlink
                    });
                    RefreshReplacements();
                    StateHasChanged();
                });
        });

        Task.Run(() =>
        {
            _client.OnReplacementLinkRemoved.Watch()
                .Subscribe(x =>
                {
                    var keyword = x.Data?.Removed?.Keyword;
                    RemovedReplacementsWithKeyword(keyword);
                    RefreshReplacements();
                    StateHasChanged();
                });
        });
    }

    private void RemovedReplacementsWithKeyword(string keyword)
    {
        var removed = _hashedComments.Where(h => h.Value.ToLower().Contains(keyword.ToLower())).Select(h => h.Key);
        foreach (var hash in removed)
        {
            _hashedComments.Remove(hash);
        }
    }

    private void RefreshReplacements()
    {
        foreach (var comment in _comments)
        {
            HashReplacement(comment.Content);
        }

        StateHasChanged();
    }

    private async Task SetInitialUser()
    {
        var result = await _client.GetUsers.ExecuteAsync();
        result.EnsureNoErrors();

        if (result.Data == null)
            throw new Exception("No users were available");

        var first = result?.Data?.User?.First();
        _user = new User { Direction = Direction.Left, Id = first?.Id ?? 0, Name = first?.Name };
        StateHasChanged();

    }
    private async Task OnShareState(object state)
    {
        if (state is not User user) return;
        _user = user;

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _stateService.Notify -= OnShareState;
    }

    private async void OnAddCommentAsync(string comment)
    {
        if (!_isValid) return;

        var result = await _client.SendMessage.ExecuteAsync(comment, _user.Id);
        result.EnsureNoErrors();

        // reset values
        _comment = string.Empty;

        StateHasChanged();
    }
    private void Enter(KeyboardEventArgs e)
    {
        // allow enter key to send comments
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
           OnAddCommentAsync(_comment);
        }
    }
}
