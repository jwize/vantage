@page "/linked-chat"
@inject ChatClient _client
@inject StateService _stateService
@inject IJSRuntime JS

@implements IDisposable

@using Vantage.Web.Models
@using StrawberryShake
@using StrawberryShake.Extensions
@using Vantage.Web.Services

<div class="container">

    <div class="box box-upper">
        @foreach (var comment in _comments)
        {
            <div class="@(GetTextDirection(comment.User.Direction)) chat-bubble">
                <small>@comment.User.Name:</small> @comment.Content

            </div>
        }
    </div>

    <div class="box box-lower form-floating;">
        <div>
            <textarea @bind="_comment" @bind:event="oninput" class="form-control" placeholder="Enter message here"
                      @onkeydown="@Enter"></textarea>
        </div>

        <div class="text-right">

            <button type="button" class="btn btn-primary add-comment"
                    @onclick="() => OnAddCommentAsync(_comment)"
                    disabled="@(!_isValid)">
                Send
            </button>
        </div>
    </div>
</div>

@code
{
    private User _user { get; set; }
    private List<Comment> _comments = new();
    private string _comment { get; set; }
    private bool _isValid => !string.IsNullOrEmpty(_comment);

    private string GetTextDirection(Direction direction)
    {
        return direction == Direction.Left ? "text-left" : "text-right";
    }
    protected override async Task OnInitializedAsync()
    {
        var result = await _client.GetComments.ExecuteAsync();
        result.EnsureNoErrors();

        // watch for comments added
        BeginCommentWatcher();
        await SetInitialUser();

        if (result.Data != null)
        {
            var data = Array.Empty<IGetComments_Comment>();
            _comments = (result.Data.Comment ?? data).Select(t => new Comment
            {
                Content = t?.Content,
                User = new User
                {
                    Name = t?.User?.Name,
                    Direction = t?.User?.Name == "Jaime" ? Direction.Left : Direction.Right
                }
            }).ToList();
        }

        await _stateService.ShareStateAsync(StateService.LinkedChat);
        _stateService.Notify += OnShareState;

        StateHasChanged();
    }

    private void BeginCommentWatcher()
    {
        Task.Run(() =>
        {
            _client.OnAddedComment.Watch()
                .Subscribe(x =>
                {
                    var comment = x.Data?.Created;

                    // update comment for all clients
                    _comments.Add(new Comment
                    {
                        Id = comment?.Id ?? 0,
                        User = new User()
                        {
                            Id = comment?.UserId ?? 0,
                            Name = comment?.User?.Name,
                            Direction = comment?.User?.Name == "Jaime" ? Direction.Left : Direction.Right
                        },
                        Content = comment?.Content,
                    });
                    StateHasChanged();
                });
        });
    }

    private async Task SetInitialUser()
    {
        var result = await _client.GetUsers.ExecuteAsync();
        result.EnsureNoErrors();

        if (result.Data == null)
            throw new Exception("No users were available");

        var first = result.Data.User.First();
        _user = new User {Direction = Direction.Left, Id = first?.Id ?? 0, Name = first.Name};
        StateHasChanged();

    }
    private async Task OnShareState(object state)
    {
        if (state is not User user) return;
        _user = user;

        await InvokeAsync(StateHasChanged);
    }

    public void Dispose()
    {
        _stateService.Notify -= OnShareState;
    }

    private async void OnAddCommentAsync(string comment)
    {
        if (!_isValid) return;

        var result = await _client.SendMessage.ExecuteAsync(comment, _user.Id);
        result.EnsureNoErrors();

        // reset values
        _comment = string.Empty;

        StateHasChanged();
    }
    private void Enter(KeyboardEventArgs e)
    {
        // allow enter key to send comments
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            OnAddCommentAsync(_comment);
        }
    }

}
